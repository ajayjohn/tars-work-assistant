name: TARS Plugin Release

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - ".claude-plugin/plugin.json"
      - ".github/workflows/release.yml"

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    name: Release Plugin

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Run full test suite
        run: |
          chmod +x tests/run-all.sh
          ./tests/run-all.sh --full

      - name: Extract version
        id: version
        run: |
          VERSION=$(python3 -c "import json; print(json.load(open('.claude-plugin/plugin.json'))['version'])")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=v$VERSION" >> "$GITHUB_OUTPUT"
          echo "Plugin version: $VERSION"

      - name: Check if tag already exists
        id: tag_check
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Tag $TAG already exists — skipping release"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "Tag $TAG does not exist — proceeding with release"
          fi

      - name: Sync marketplace.json version
        if: steps.tag_check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Sync version from plugin.json to marketplace.json (always in .claude-plugin/)
          python3 << 'PYTHON_SCRIPT'
          import json

          with open('.claude-plugin/plugin.json', 'r') as f:
              source = json.load(f)

          with open('.claude-plugin/marketplace.json', 'r') as f:
              marketplace = json.load(f)

          # Update TARS plugin entry in marketplace
          for plugin in marketplace.get('plugins', []):
              if plugin['name'] == 'tars':
                  plugin['version'] = source['version']
                  plugin['description'] = source['description']
                  break

          with open('.claude-plugin/marketplace.json', 'w') as f:
              json.dump(marketplace, f, indent=2)

          print(f"✓ Synced .claude-plugin/marketplace.json to v{source['version']}")
          PYTHON_SCRIPT

          # Commit marketplace.json if changed
          if ! git diff --quiet .claude-plugin/marketplace.json; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .claude-plugin/marketplace.json
            git commit -m "chore: sync marketplace.json to v${VERSION}"
            git push origin main
          fi

      - name: Auto-update documentation
        if: steps.tag_check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Generate skill inventory from plugin.json + frontmatter
          python3 -c "
          import json, os, re

          root = '.'
          with open('.claude-plugin/plugin.json') as f:
              manifest = json.load(f)

          # Build skill table
          skills = []
          for skill_path in manifest.get('skills', []):
              full = os.path.join(root, skill_path)
              if not os.path.isfile(full):
                  continue
              with open(full) as sf:
                  content = sf.read()
              fm = re.match(r'^---\s*\n(.*?)\n---', content, re.DOTALL)
              if not fm:
                  continue
              name = desc = invocable = ''
              for line in fm.group(1).split('\n'):
                  line = line.strip()
                  if line.startswith('name:'):
                      name = line.split(':', 1)[1].strip()
                  elif line.startswith('description:'):
                      desc = line.split(':', 1)[1].strip()
                  elif line.startswith('user-invocable:'):
                      invocable = line.split(':', 1)[1].strip()
              skills.append({'name': name, 'desc': desc, 'invocable': invocable})

          # Build command table
          commands = []
          for cmd_path in manifest.get('commands', []):
              full = os.path.join(root, cmd_path)
              if not os.path.isfile(full):
                  continue
              with open(full) as cf:
                  content = cf.read()
              fm = re.match(r'^---\s*\n(.*?)\n---', content, re.DOTALL)
              if not fm:
                  continue
              desc = ''
              for line in fm.group(1).split('\n'):
                  line = line.strip()
                  if line.startswith('description:'):
                      desc = line.split(':', 1)[1].strip()
              cmd_name = os.path.basename(cmd_path).replace('.md', '')
              commands.append({'name': cmd_name, 'desc': desc})

          # Output inventory
          print(f'Skills: {len(skills)}')
          for s in skills:
              marker = '(bg)' if s['invocable'] == 'false' else ''
              print(f\"  - {s['name']} {marker}: {s['desc']}\")
          print(f'Commands: {len(commands)}')
          for c in commands:
              print(f\"  - /{c['name']}: {c['desc']}\")
          "

          echo "Documentation auto-update complete for v${VERSION}"

      - name: Build plugin archive
        if: steps.tag_check.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ARCHIVE="tars-v${VERSION}.zip"

          # Create temporary build directory
          mkdir -p build-temp/.claude-plugin

          # Copy plugin files
          cp -r skills commands scripts reference build-temp/
          cp .mcp.json LICENSE NOTICE build-temp/

          # Create minimal plugin.json and sync marketplace.json
          python3 << 'PYTHON_SCRIPT'
          import json

          # Read source plugin.json
          with open('.claude-plugin/plugin.json', 'r') as f:
              source = json.load(f)

          # Create minimal version (Cowork auto-discovers skills/commands from directory structure)
          minimal = {
              "name": source["name"],
              "version": source["version"],
              "description": source["description"],
              "author": source["author"]
          }
          if "license" in source:
              minimal["license"] = source["license"]

          # Write minimal version
          with open('build-temp/.claude-plugin/plugin.json', 'w') as f:
              json.dump(minimal, f, indent=2)

          print(f"✓ Created minimal plugin.json for Cowork distribution (v{minimal['version']})")
          PYTHON_SCRIPT

          # Create archive from build directory
          cd build-temp
          zip -r "../$ARCHIVE" . -x "*.pyc" -x "__pycache__/*"
          cd ..

          # Cleanup
          rm -rf build-temp

          echo "archive=$ARCHIVE" >> "$GITHUB_ENV"
          echo "Built Cowork-compatible archive: $ARCHIVE"

      - name: Extract changelog for release
        if: steps.tag_check.outputs.exists == 'false'
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Extract the changelog section for this version
          python3 -c "
          import re, sys

          with open('CHANGELOG.md') as f:
              content = f.read()

          # Find section for this version
          pattern = rf'## v?{re.escape(\"$VERSION\")}.*?\n(.*?)(?=\n## |\Z)'
          match = re.search(pattern, content, re.DOTALL)
          if match:
              notes = match.group(1).strip()
              # Limit to 5000 chars for GitHub release
              if len(notes) > 5000:
                  notes = notes[:4997] + '...'
              print(notes)
          else:
              print(f'Release v{\"$VERSION\"}')
          " > /tmp/release_notes.md

          echo "Release notes extracted"

      - name: Create git tag
        if: steps.tag_check.outputs.exists == 'false'
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"

      - name: Create GitHub release
        if: steps.tag_check.outputs.exists == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: TARS ${{ steps.version.outputs.tag }}
          body_path: /tmp/release_notes.md
          files: ${{ env.archive }}
          draft: false
          prerelease: false
